스트림
===
스트림이란?
---
데이터소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 저의해 놓았다.

스트림을 이용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은방식으로 다룰 수 있다.

 - 예시
```java
String[] strArr = {"aaa","ddd","ccc"};
List<String> strList = Arrays.asList(strArr);
```
두 데이터 소스를 기반으로 하는 스트림은 다음과 같이 생성한다.
```java
Stream<String> strStream1 = strList.stream();   // 스트림 생성
Stream<String> strStream2 = Arrays.asList(strArr);  // 스트림 생성
```
두 스트림으로 데이터 소스의 데이터를 읽어서 정렬하고 화면에 출력하는 방법은 다음과 같다.
```java
strStream1.sorted().forEach(System.out::println);
strStream2.sorted().forEach(System.out::println);
```

<br>

### **스트림은 데이터 소스를 변경하지 않는다**
스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도있다.

```java
// 정렬된 결과를 새로운 List에 담아서 반환한다.
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

<br>

### **스트림은 일회용이다**
스트림은 Iterator처럼 일회용이다. Iterator로 컬렉션의 요소를 모두 일고나면 다시 상용할 수 없는 것처럼, 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다.

<br>

### **스트림은 작업을 내부 반복으로 처리한다.**
스트림의 장점중 하나가 '내부 반복'이다. 내부 반복이란 반복문을 메서드 내부에 숨길 수 있다는 것을 의미한다. forEach()는 스트림에 정의된 메서드 중 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.

<br>

### **스트림의 연산**
데이터베이스에 SELECT처럼쿼리를 하는 것 처럼 다양한 연산을 이용해 복잡한 작업을 간단히 처리할 수 있다.

스트림이 제공하는 연산은 중간 연산과 최종 연산으로 분류할 수 있다.

    중간연산    연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산할 수 있음
    최종연산    연산 결과가 스트림이 아닌. 스트림의 요소를 소모하므로 단 한번만 가능

    stream.distinct().limit(5).sorted().forEach(System.out::println)
            중간연산   중간연산  중간연산        최종 연산
    
모든 중간연산의 결과는 스트림이지만, 연산 전의 스트림과 같은 것은 아니다. 위의 문자과 달리 모든 스트림 연산은 나누어 쓰면 아래와 같다. 각 연산의 **반환타입**을 눈여겨보자

```java
String[] atrArr = {"dd","aaa","CC","cc","b"};
Stream<String> stream = Stream.of(strArr)            // 문자열 배열이 소스인 스트림
Stream<String> filteredStream = stream.filter();     // 걸러내기(중간 연산)
Stream<String> distinctedStream = stream.distinct(); // 중복제거(중간 연산)
Stream<String> sortedStream = stream.sort();         // 정렬(중간 연산)
Stream<String> limitedStream = stream.limit(5)       // 스트림 자르기(중간 연산)
int            total         = stream.count();       // 요소 개수 세기(최종 연산)
```

- 연산 정리

|<center>중간 연산</center>|<center>설명</center>|
|-|-|
|Stream\<T> distinct()|중복을 제거|
|Stream\<T> filter(Predicate\<T> predicate)|조건에 안 맞는 요소 제외|
|Stream\<T> limit(long maxSize|스트림의 일부를 잘라낸다.|
|Stream\<T> skip(long n)|스트림의 일부를 건너뛴다.|
|Stream\<T> peek(Consumer\<T> action)|스트림의 요소에 작업수행|
|Stream\<T> sorted()<br>Stream\<T> sorted(Comparator\<T> comparator|스트림 요소를 정렬한다.|
|Stream\<R> map(Function\<T,R> mapper)<br>DoubleStream mapToDouple(ToDoubleFunction\<T> mapper)<br>IntStream mapToInt(ToIntFunction\<T> mapper)<br>LongStream mapToLong(ToLongFunction\<T> mapper)<br><br>Stream\<R> flatMap(Function\<T,Stream\<R>> mapper)<br>DoubleStream flatMapToDouble(Function\<T,DoubleStream> m)<br>IntStream flatMapToInt(Function\<T,IntStream> m)<br>LongStream flatMapToLong(Function\<T,LongStream> m)|스트림의 요소를 변환한다.|


|<center>최종 연산</center>|<center>설명</center>|
|-|-|
|void forEach(Consumer\<? super T> action)<br>void forEachOrdered(consumer\<? super T> action)|각 요소에 지정된 작업 수행|
|long count()|스트림의 요소의 개수 반환|
|Optional\<T> max(comparator\<? super T> comparator)<br>Optional\<T> min(comparator\<? super T> comparator)|스트림의 최대값/ 최소값을 반환|
|Optional\<T> findAny()  //아무거나 하나<br>Optional\<T> findAny() // 첫 번쨰 요소|스트림의 요소 하나를 반환|
|boolean allMatch (predicate\<T> p) // 모두 만족하는지<br>boolean anyMatch (predicate\<T> p) // 하나라도 만족하는지<br>boolean noneMatch (predicate\<> p) // 모두 만족하지 않는지|주어진 조건을 모든 요소가 만족시키는지, 만족시키지 않는지 확인|
|object[] toArray()<br>A[] toArray(IntFunction\<A[]> generator)|스트림의 모든 요소를 배열로 반환|
|Optional\<T> reduce(BinaryOperator\<T> accumulator)<br>T reduce(T identity, BinaryOperator\<T> accumulator)<br>U reduce(U identity, BiFunction\<U,T,U> accumulator, BinaryOperator\<U> combiner)|스트림의 요소를 하나씩 줄여가면서(리듀싱) 계산한다.|
|R collect(Collector\<T,A,R> collector)<br>R collect(Supplier\<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R> combiner)|스트림의 요소를 수집한다.<br>주로 요소를 그룹화하거나 분할한 결과를 컬렉션에 담아 반환하는데 사용된다.|

중간연산은 map()과 flatMap(), 최종 연산은 reduce()와 collect()가 핵심이다.

<br>

### **지연된 연산**
스트림은 최종연산이 수행되기 전까지는 중간 연산이 수행되지 않는다는 것이다. 중간연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다. 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.

<br>

### **Stream\<Integer>와 IntStream**
오토박싱&언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 스트림, IntStream, LongStream, DoubleStream이 제공된다. IntStream에는 int타입의 값으로 작업하는데 유용한 메서드들이 포함되어 있다.

### **병렬 스트림**
스트림 데이터를 다룰 때의 장점중 하나가 병렬 처리가 쉽다는 것이다. parallel()이라는 메서드를 호출해주면 병렬 스트림은 내부적으로 fork&join프레임웍을 이용해서 자동적으로 연산을 병렬로 수행한다. 반대로 병렬로 처리되지 않게 하려면 sequential()을 호출하면 된다.

모든 스트림은 기본적으로 병렬 스트림이 아니므로 parallel()을 호출한 것을 취소할 때만 사용한다.

#### <br>

스트림 만들기
---
스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등 다양하며, 이 다양한 소스들로부터 스트림을 생성하는 방법에 대해 배우게 될 것이다.

<br>

### **컬렉션**
컬렉션의 최고 조상인 Collection에 Stream()이 정의되어 있다. 그래서 Collection의 자손인 List와 Set을 구현한 클래스들은 모두 이 메서드로 스트림을 생성할 수 있다.

    Stream<T> Collection.stream()
Stream()은 해당 컬렉션을 소스(source)로 하는 스트림을 반환한다.

- List로부터 스트림을 생성
```java
List<Integer> list = Arrays.asList(1,2,3,4,5);  // 가변인자
Stream<Integer> intStream = list.stream();      // list를 소스로 하는 컬렉션 생성
```

### **배열**
배열을 소스로 하는 스트림을 생성하는 메서드는 다음과 같이 Stream과 Arrays에 static메서드로 정의되어 있다.

    Stream<T> Stream.of(T... values)    // 가변인자
    Stream<T> Stream.of(T[])
    Stream<T> Arrays.stream(T[])
    Stream<T> Arrays.stream(T[] array, int startInclusive, int endExclusiv)

예를 들어 문자열 스트림은 다음과 같이 생성한다.

    Stream<T> Stream.of("a","b","c")    // 가변인자
    Stream<T> Stream.of(new String[]{"a","b","c"})
    Stream<T> Arrays.stream(new String[]{"a","b","c"})
    Stream<T> Arrays.stream(new String[]{"a","b","c"}, 0, 3)