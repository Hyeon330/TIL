애너테이션(annotation)
===
애너테이션이란?
---
자바를 개발한 사람들은 소스코드에 대한 문서를 따로 만들기보다 소스코드와 문서를 하나으 ㅣ파일로 관리하는 것이 낫다고 생각했다. 그래서 소스코드의 주석/** ~ */ 에 소스코드에 대한 정보를 저장하고, 주석으로부터 HTML문서를 생성해내는 프로그램(javadoc.exe)을 만들어 사용했다.

'/**'로 시작하는 주석안에 소스코드에 대한 설명들이 있고, 그 안에'@'이 붙은 태그들이 있다.

미리 정리된 태그들을 이용해서 주석안에 정보를 저장하고, javadoc.exe라는 프로그램이 이 정보를 읽어 문서를 작성하는데 사용한다.

이 기능을 응용하여, 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 애너테이션이다.

###### <br>
표준 애너테이션
---
JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다.

자바에서 기본적으로 제공하는 애너테이션들은 몇 개 없다. 그나마 이들의 일부는 '메타 애너테이션(meta annotation)'으로 애너테이션을 정의하는데 사용되는 애너테이션의 애너테이션이다.

|<center>애너테이션</center>|<center>설명</center>|
|:-|:-|
|@Override|컴파일러에게 오버라이딩하는 메서드라는 것을 알린다.|
|@Deprecated|앞으로 사용하지 않을 것을 권장하는 대상에게 붙인다.|
|@SuppressWarnings|컴파일러의 특정 경고메시지가 나타나지 않게 해준다.|
|@SafeVarargs|지네릭스 타입의 가변인자를 사용한다.(JDK1.7)|
|@FunctionalInterface|함수형 인터페이스라는 것을 알린다(JDK1.8)|
|@Nativ|native메서드에서 참조되는 상수 앞에 붙인다.(JDK1.8)|
|@Target*|애너테이션이 적용가능한 대상을 지정하는데 사용한다.|
|@Documented*|애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다.|
|@Inherited*|애너테이션이 자손 클래스에 상속되도록 한다.|
|@Retention*|애너테이션이 유지되는 범위를 지정하는데 사용한다.|
|@Repeatable*|애너테이션을 반복해서 적용할 수 있게 한다.(JDK1.8)|

※ *가 붙은 것은 메타 애너테이션

**@Override**<br>
메서드 앞에만 붙일 수 있는 애너테이션으로, 조상 메서드를 오버라이딩하는 것이라는걸 컴파일러에게 알려주는 역할을 한다.
```java
class Child extends Parent {
    @Override
    void parentMethod(){...}
}
```
위와 같이 메소드 위쪽에 애너테이션을 해주면 컴파일러가 조상 클래스에서 같은 이름의 메서드가 있는지 확인하고 없으면, 에러메시지를 출력한다.

**@Deprecated**<br>
새로운 버젼의 JDK가 소개될 때, 새로운 기능이 추가될 뿐만 아니라 기존의 부족했던 기능들을 개선하기도 한다. 이 과정에서 기존의 기능을 대체할 것들이 추가되어도, 이미 여러 곳에서 사용되고 있을지 모르기 때문에 더 이상 사용되지 않은 필드나 메서드에 '@Deprecated'를 붙이는 것이다.

만일 '@Deprecated'가 붙은 대상을 사용시 아래와 같은 에러 메시지가 출력 되면서 프로그램이 실행 된다.

    Note: 소스파일명.java users or overrides a deprecated API.
    Note: Recompile with -Xlint:deprecation for details.

**@FunctionalInterface**<br>
'함수형 인터페이스(functional interface)'를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 '함수형 인터페이스'를 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생시킨다.

붙이면 실수를 방지할 수 있으므로 '함수형 인터페이스'를 선언할 때는 이 애너테이션을 반드시 붙이도록 하자.

**@SuppressWarnings**<br>
컴파일러가 보여주는 경고메시지가 나타나지 않게 억제해준다. 억제하려는 경고메시지를 애너테이션의 두에 괄호()안에 문자열로 지정하면 된다.
```java
@SuppressWarnings("unchecked")      // 지네릭스와 관련된 경고를 억제
ArrayList list = new ArrayList();   // 지네릭 타입을 지정하지 않았음
list.add(obj);                      // 여기서 경고 발생
```
둘 이상의 경고 억제시

    @SuppressWarnings({"deprecation","unchecked","varargs"})

새로 추가된 경고 메시지를 억제하려면, 경고 메시지의 종류를 알아야 하는데, -Xlint옵션으로 컴파일해서 나타나는 경고의 내용 중에서 대괄호[] 안에 있는 것이 메시지 종류이다.

오류 메시지

    C:>javac -Xlint AnnotationTest.java     // console에서 컴파일 명령
    AnnotationTest.java:15: warning: [rawtypes] found raw type: List
        public stativ void sort(List list)
                                ^
      missing type arguments for generic class List<E>
      where E is a type-variable:
        E extends Object declared in interface List

**@SafeVarargs**<br>
메서드에 선언된 가변인자의 타입이 non-reifiable타입일 경우, 해당 메서드를 선언하는 부분과 호출하는 부분에서 "unchecked"경고가 발생한다. 해당 코드에 문제가 없다면 경고 억제를 위해 '@SafeVarargs'를 선언한다.

이 애너테이션은 static이나 final이 붙은 메서드나 생성자에만 붙일 수 있다.

컴파일 후에도 제거되지 않는 타입을 reifiable타입이라고 하고, 제거되는 타입을 non-reifiable타입이라고 하는데, 지네릭 타입들은 대부분 컴파일 시에 제거되므로 non-reifiable타입이다.

```java
public static <T> List<T> asList(T... a) {
    return new ArrayList<T>(a); // ArrayList(E[] array)를 호출. 경고발생
}
```
asList()의 매개변수가 가변인자인 동시에 지네릭 타입이다. 메서드에 선언된 타입 T는 컴파일 과정에서 Object로 바뀐다. Object[]에는 모든 타입의 객체가 들어있을 수 있으므로, 이 배열로 ```ArrayList<T>```를 생성하는 것은 위험하다고 경고 하는 것이다.

그러나 asList()가 호출되는 부분을 컴파일러가 체크해서 타입 T가 아닌 다른 타입이 들어가지 못하게 할 것이므로 위의 코드는 아무런 문제가 없다.

이럴 때 메서드 앞에 '@SaveVarargs'를 붙여서 경고가 발생하지 안도록 해야 한다.

###### <br>
메타 애너테이션
---
- 애너테이션을 위한 애너테이션
- 애너테이션을 정의할 때 애너테이션의 적용대상(target)이나 유지기간(retention)등을 지정하는데 사용한다.

**@Target**<br>
애너테이션이 적용가능한 대상을 지정하는데 사용한다.
```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```
위의 코드는 '@SuppressWarnings'를 정의한 것이다. 이 애너테이션에 적용할 수 있는 대상을 '@Target'으로 지정하였다.

'@Target'으로 지정할 수 있는 애너테이션 적용대상의 종류

|<center>대상 타입</center>|<center>의미</center>|
|:-|:-|
|||