JVM의 메모리 구조
---
응용프로그램 실행 시 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역(method area, call stack, heap, 등)으로 나누어 관리한다.

<p align="center">
<img src="../TIL_img/22.01.07/JVM_Memory.jpg">
</p>

**1. 메서드 영역(method area)**
   - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한정보(클래스데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.

**2. 힙(heap)**
   - 인스턴스, 인스턴스 변수가 생성되는 공간.
   - 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.

**3. 호출스택(call stack 또는 execution stack)**
   - 메서드의 작업에 필요한 메모리 공간을 제공
   - 메서드 호출 시, 호출스택에 호출된 메서드를 위한 메모리가 할당
   - 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용
   - 메서드가 작업을 마치면 할당되었던 메모리공간 반환

**호출스택의 특징**
- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당 받는다
- 메서드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

```java
class CallStackTest {
    public static void main(String[] args) {
        firstMethod();
    }

    static void firstMethod(){
        secondMethod();
    }

    static void secondMethod(){
        System.out.println("secondMethod()");
    }
}
```
**예제 실행 시 호출스택의 변화**
<p align="center">
<img src="../TIL_img/22.01.07/CallStackTest.png" width="90%">
</p>

#### <br>
기본형 매개변수와 참조형 매개변수
---
메서드 호출 시 매개변수의 타입이 기본형(primitive type)일 때는 기본형 값이 복사가되고, 참조형(reference type)일 경우 인스턴스 주소가 복사된다.

기본형으로 선언하면 단순히 저장된 값만 얻지만, 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어오는 것은 물론이고, 변경하는 것도 가능하다.

- 기본형 : 변수의 값을 읽기만 할 수 있다.(read only)
- 참조형 : 변수의 값을 읽고 변경할 수 있다.(read & write)

```java
class Data { int x; }

class PrimitiveParamEx {
    public static void main(String[] args) {
        Data d = new Data();
        d.x = 10;
        System.out.println("main() : x = " + d.x);
        
        changeP(d.x);
        System.out.println("After changeP(d.x)");
        System.out.println("main() : x = " + x);

        changeR(d);
        System.out.println("After changeP(d)");
        System.out.println("main() : x = " + x);
    }

    static void changeP(int x) {  // 기본형 변수
        x = 1000;
        System.out.println("changeP() : x = " + x);
    }

    static void changeR(Data x) {  // 참조형 변수
        x = 1000;
        System.out.println("changeR() : x = " + x);
    }
}
```
실행결과
```java
main() : x = 10
changeP() : x = 1000
After changeP(d.x)
main() : x = 10
changeR() : x = 1000
After changeR(d)
main() : x = 1000
```
>changeP()메서드를 호출시에는 d.x의 값이 변경된 것이 아니라, changP메서드의 매개변수 x의 값이 변경된 것이다.
>
>changeR()메서드를 호출시에는 매개변수가 참조형이라서 주소를 넘겨주었기 때문에 값을 읽어오는 것 뿐만 아니라 변경하는 것도 가능하다.

**참조변수를 다루는 여러가지 예제**
```java
class ReferenceParamEx {
    public static void main(String[] args) {
        int[] arr = {3,2,1,6,5,4};

        printArr(arr);  // 배열의 모든 요소 출력
        sortArr(arr);   // 정렬
        printArr(arr);  // 정렬 후 결과 출력
        System.out.println("sum=" + sumArr(arr));   // 배열의 총합을 출력
    }

    static void printArr(int[] arr) {       // 배열의 모든 요소 출력
        System.out.println("[");

        for(int i : arr) {
            System.out.print(i+",");
        }
        System.out.println("]");
    }

    static int sumArr(int[] arr) {          // 배열의 총합 반환
        int sum = 0;

        for(int i : arr) {
            sum += i;
        }
        return sum;
    }

    static void sortArr(int[] arr) {        // 오름차순 정렬
        for(int i = 0; i < arr.length - 1; i++) {
            for(int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                }
            }
        }
    }
}
```
실행결과
```
[3,2,1,6,5,4,]
[1,2,3,4,5,6,]
sum=21
```

#### <br>
참조형 반환타입
---
매개변수 뿐만 아니라 반환타입도 참조형이 될 수 있다.
```java
class Data { int x; }

class ReferenceReturnEx {
    public static void main(String[] args) {
        Data d = new Data();
        d.x = 10;

        Data d2 = copy(d);
        System.out.println("d.x = " + d.x);
        System.out.println("d2.x = " + d2.x);
    }

    static Data copy(Data d) {
        Data tmp = new Data();
        tmp.x = d.x;

        return tmp;
    }
}
```
실행결과
```
d.x = 10;
d2.x = 10;
```
main함수에서 생성한 d객체를 copy메서드의 매개변수로 줘서 copy메서드 내부의 tmp객체의 tmp.x의 값을 d.x로 설정해 주었다. 이로서 d.x와 tmp.x의 값은 같아진 것이다. 반환한 tmp의 값을 d2에 저장하였기 때문에 d.x의 값과 d2.x의 값이 같은 것이다.
>반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을의미한다.

#### <br>
참조형 반환타입
---
메서드 내부에서 메서드 자신을 다시 호출하는 것을 '재귀호출(recursive call)'이라 하고, 재귀호출을 하는 메서드를 '재귀 메서드'라 한다.
```java
void method() {
    method();
}
```
>호출된 메서드는 '값에 의한 호출(call by value)'을 통해, 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메서드와 관계없이 독립적인 작업수행이 가능하다.
```java
void method(int n) {
    while(n != 0) {
        System.out.println(n--);
    }
}
```
>첫 번째 예제처럼 재귀호출뿐이라면, 무한반복을 해버린다. 무한반복문에 조건문이 필수인 것 처럼, 재귀호출도 조건문이 필수적으로 따라다닌다.

>반복문은 그저 같은 문장을 반복해서 수행하는 것이지만, 메서드를 호출하는 것은 매개변수 복사와 종료 후 복귀할 주소저장 이 추가로 필요하기 때문에 반복문보다 재귀호출의 수행시간이 더 오래 걸린다.

**Factorial예제**
```java
class FactorialTest {
    public static void main(String args[]) {
        int result = factorial(4);

        System.out.println(result);
    }

    static int factorial(int n) {
        int result = 0;

        if(n == 1) {
            result = 1;
        } else {
            result = n * factorial (n-1);   // 자신을 호출
        }

        return result;
    }
}
```
실행결과
```
24
```
>n==4일 경우  
else로 들어가 factorial(3)을 호출한다  
n==3일 경우  
else로 들어가 factorial(2)을 호출한다  
n==2일 경우  
else로 들어가 factorial(1)을 호출한다  
n==1일 경우  
result 1로 리턴하고  
1 x 2를 리턴하고  
2 x 3을 리턴하고  
6 x 4를 리턴하면  
결과는 24가 나온다.

#### <br>
클래스 메서드(static메서드)와 인스턴스 메서드
---
- 메서드 앞에 static이 븥어있으면 클래스메서드이고 붙어있지 않으면 인스턴스 메서드이다.
- 클래스 메서드도 클래스변수처럼, 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)'와 같은 식으로 호출이 가능하다.
- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
- 인스턴스와 관게없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는)메서드를 클래스 메서드(static메서드)로 정의한다.

**1. 클래스를 설계할 때 , 맴버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.**
- 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의해야 한다.

**2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.**
- static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.

**3. 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.**
- 클래스 메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스변수의 사용을 금지한다. 반면에 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.

**4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙으는 것을 고려한다.**
- 메서드의 작업내용 중에서 인스턴스변수를 필요로 하지 않는다면 static을 붙이는 것이 좋다. 메서드 호출시간이 짧아지므로 성능이 향상된다. 인스턴스메서드는 실행 시 호출되어야 할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.

>클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야 하는 것이 있는지 살펴보고 있으면, static을 붙여준다.
>
>작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려한다.


#### <br>
클래스 멤버와 인스턴스 멤버간의 참조와 호출
---
같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 하지만 **클래스멤버가 인스턴스멤버를 참조 또는 호출할 경우에는 인스턴스를 생성**해야 한다.

클래스멤버가 존재하는 시점에 인스턴스멤버가 존재하지 않을 수도 있기 때문이다.

```java
class TestClass{
    void instanceMethod() {}        // 인스턴스메서드
    static void staticMethod() {}   // static메서드

    void instanceMethod2() {
        instanceMethod2();
        staticMethod();
    }

    static void staticMethod2() {   // static메서드 에서
        instanceMethod();           // 에러!! 인스턴스 메서드를 바로 호출할 수 없다.
        staticMethod();
    }
}
```
