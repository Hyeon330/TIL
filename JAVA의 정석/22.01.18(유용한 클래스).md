유용한 클래스
===
java.util.Objects클래스
---
- Object클래스의 보조 클래스
- Math클래스처럼 모든 메서드가 'static'이다.
- 객체의 비교나 널 체크(null check)에 유용하다.

```java
static boolean isNull(Object obj)
static boolean nunNull(Object obj)
```
- **isNull()** : 해당 객체가 null인지 확인해서 null이면 true를 반환
- **nonNull()** : isNull()과 반대 일

* **requireNonNull()**<br>
  해당 객체가 널이 아니어야 하는 경우에 사용한다. 만일 객체가 널이면, NullPointerException을 발생시킨다. 두 번째 매개변수로 지정하는 문자열은 예외의 메시지가 된다.

```java
void setName(String name) {
    if(name == null) 
        throw new NullPointerException("name must not b null.");

    this.name = name;
}
```
```java
void setName(String name) {
    this.name = Objects.requireNonNull(name, "name must not be null.");
}
```
>위의 코드를 아래 코드로 바꿀 수 있다.

- **equals(Object a, Object b)**
  String이 아닌 Object에 정의된 메서드로 이 메서드의 장점은 null검사를 하지 않아도 된다.  
  equals()는 내부에서 a와 b의 널 검사를 하기 때문에 따로 널 검사를 하기 위한 조건식을 따로 넣지 않아도 되는 것이다.
```java
static boolean equals(Object a, Object b)
static boolean deepEquals(Object a, Object b)
```
실제코드
``` java
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}
```
>deepEquals()는 객체를 재귀적으로 비교하기 때문에 다차원 배열의 비교도 가능하다.

```java
import java.util.*;
import static java.util.Objects.*;

class ObjectTest {
    public static void main(String[] args) {
        String[][] str2D = new String[][] { { "aaa", "bbb" }, { "AAA", "BBB" } };
        String[][] str2D_2 = new String[][] { { "aaa", "bbb" }, { "AAA", "BBB" } };

        System.out.print("strD = {");
        for (String[] tmp : str2D) {
            System.out.print(Arrays.toString(tmp));
        }
        System.out.println("}");

        System.out.print("strD_2 = {");
        for (String[] tmp : str2D_2) {
            System.out.print(Arrays.toString(tmp));
        }
        System.out.println("}");

        System.out.println("equals(str2D, str2D_2)=" + Objects.equals(str2D, str2D_2));
        System.out.println("deepEquals(str2D, str2D_2)=" + Objects.deepEquals(str2D, str2D_2));

        System.out.println("isNull(null) =" + isNull(null));
        System.out.println("nonNull(null) =" + nonNull(null));
        System.out.println("hashCode(null) =" + Objects.hashCode(null));
        System.out.println("toString(null) = " + Objects.toString(null));
        System.out.println("toString(null, \"\") =" + Objects.toString(null, ""));
    }
}
```
실행결과

    strD = {[aaa, bbb][AAA, BBB]}
    strD_2 = {[aaa, bbb][AAA, BBB]}
    equals(str2D, str2D_2)=false
    deepEquals(str2D, str2D_2)=true
    isNull(null) =true
    nonNull(null) =false
    hashCode(null) =0
    toString(null) = null
    toString(null, "") =

###### <br>

java.util.Randem클래스
---
### **Random클래스의 생성자와 메서드**
생성자 Random()은 종자값을 System.currentTimeMillis()로 하기 때문에 실행할 때마다 얻는 난수가 달라진다.

**Random클래스의 메서드 목록**
|<center>메서드</center>|<center>설명</center>|
|:-|:-|
|Random()|현재시간(System.currentTimeMillis())을 종자값(seed)으로 싱요하는 Random인스턴스를 생성한다.|
|Random(long seed)|매개변수seed를 종자값으로 하는 Random인스턴스를 생성한다.|
|boolean nextBoolean()|boolean타입의 난수를 반환한다.|
|void nextBytes(byte[] bytes)|bytes배열에 byte타입의 난수를 채워서 반환한다.|
|double nestDouble()|double타입의 난수를 반환한다.(0.0 <= x < 1.0)|
|float nextFloat()|float타입의 난수를 반환한다.(0.0 <= x < 1.0)|
|double nextGaussian()|평균은 0.0이고 표준편차는 1.0인 가우시안(Gaussian)분포에 따른 double형의 난수를 반환한다.|
|int nextInt()|int타입의 난수를 반환한다(int의 범위)|
|int nextInt(int n)|0 ~ n의 범위에 있는 int값을 반환한다.(n은 범위에 포함되지 않음)|
|long nextLong()|long타입의 난수를 반환한다.(long의 범위)|
|void setSeed(long seed)|종자값을 주어진 값(seed)으로 변경한다.|
>각 메서드가 반환하는 값의 범위와 nextBytes()는 BigInteger(int signum, byte[] magnitude)와 함께 사용하면 int의 범위인 '-2<sup>31</sup> ~ 2<sup>31</sup>-1'보다 넓은 범위의 난수를 얻을 수 있다는 정도만 확인하자.

<br>

### 정규식(Regular Expression) - java.util.regex패키지
- 정규식이란 텍스트 데이터 중에서 원하는 조건(패턴, pattern)과 일치하는 문자열을 찾아내기 위해 사용하는 것으로 미리 정의된 기호와 문자를 이용해서 작성하는 문자열을 말한다.
- 많은 양의 텍스트 파일 중에서 원하는 데이터를 손쉽게 뽑아낼 수 있다.
- 입력된 데이터가 형식에 맞는지 체크할 수도 있다.

```java
import java.util.regex.*;

class RegulaerEx {
    public static void main(String[] args) {
        String[] data = { "bat", "baby", "bonus", "cA", "ca", "co", "c.", "c0", "car", "combat", "count", "date",
                "disc" };
        Pattern p = Pattern.compile("c[a-z]*"); // c로 시작하는 소문자 영단어

        for (int i = 0; i < data.length; i++) {
            Matcher m = p.matcher(data[i]);
            if (m.matches())
                System.out.print(data[i] + ",");
        }
    }
}
```
실행결과

    ca,co,car,combat,count,

Pattern은 정규식을 정의하는데 사용되고 Matcher는 정규식(패턴)을 데이터와 비교하는 역할을 한다.

1. 정규식을 매개변수로 Pattern클래스의 strtic메서드인 Pattern compile(String regex)을 호출하여 Pattern인스턴스를 얻는다.
```java
Pattern p = Pattern.compile("c[a-z]*");
```
2. 정규식으로 비교할 대상을 매개변수로 Patther클래스의 Matcher catcher(CharSequence input)를 호출해서 Matcher인스턴스를 얻는다.
```java
Matcher m = p.matcher(data[i]);
```
3. Matcher인스턴스에 boolean matches()를 호출해서 정규식에 부합하는지 확인한다.
```java
if(m.matches())
```

**자주 쓰일만한 패턴 예제**
```java
class RegularEx {
    public static void main(String[] args) {
        String[] data = { "bat", "baby", "bonus", "c", "cA", "ca", "co", "c.", "c0", "c#", "car", "combat", "count",
                "date", "disc" };

        String[] pattern = { ".*", "c[a-z]*", "c[a-z]", "c[a-zA-Z]", "c[a-zA-Z0-9]", "c.", "c.*", "c\\.", "c\\w",
                "c\\d", "c.*t", "[b|c].*", ".*a.*", ".*a.+", "[b|c].{2}" };

        for (int x = 0; x < pattern.length; x++) {
            Pattern p = Pattern.compile(pattern[x]);
            System.out.print("Pattern : " + pattern[x] + " 결과: ");
            for (int i = 0; i < data.length; i++) {
                Matcher m = p.matcher(data[i]);
                if (m.matches())
                    System.out.print(data[i] + ",");
            }
            System.out.println();
        }
    }
}
```
실행결과

    Pattern : .* 결과: bat,baby,bonus,c,cA,ca,co,c.,c0,c#,car,combat,count,date,disc,
    Pattern : c[a-z]* 결과: c,ca,co,car,combat,count,
    Pattern : c[a-z] 결과: ca,co,
    Pattern : c[a-zA-Z] 결과: cA,ca,co,
    Pattern : c[a-zA-Z0-9] 결과: cA,ca,co,c0,
    Pattern : c. 결과: cA,ca,co,c.,c0,c#,
    Pattern : c.* 결과: c,cA,ca,co,c.,c0,c#,car,combat,count,
    Pattern : c\. 결과: c.,
    Pattern : c\w 결과: cA,ca,co,c0,
    Pattern : c\d 결과: c0,
    Pattern : c.*t 결과: combat,count,
    Pattern : [b|c].* 결과: bat,baby,bonus,c,cA,ca,co,c.,c0,c#,car,combat,count,
    Pattern : .*a.* 결과: bat,baby,ca,car,combat,date,
    Pattern : .*a.+ 결과: bat,baby,car,combat,date,
    Pattern : [b|c].{2} 결과: bat,car,

|<center>정규식 패턴</center>|<center>설명</center>|<center>결과</center>|
|:-|:-|:-|
|c[a-z]*|c로 시작하는 영단어|c,ca,co,car,combat,count,|
|c[a-z]|c로 시작하는 두 자리 영단어|ca,co,|
|c[a-zA-Z]|c로 시작하는 두 자리 영단어(a~z 또는 A~Z. 즉, 대소문자 구분안함)|cA,ca,co,|
|c[a-zA-Z0-9]<br>c\w|c로 시작하고 숫자와 영어로 조합된 두 글자|cA,ca,co,c0|
|.*|모든 문자열|bat,baby,bonus,c,cA,ca,co,c.,c0,c#,car,combat,count,date,disc,|
|c.|c로 시작하는 두 자리 문자열|cA,ca,co,c.,c0,c#,|
|c.*|c로 시작하는 모든 문자열(기호포함)|cA,ca,co,c.,c0,c#,car,combat,count,|
|c＼.|c.와 일치하는 문자열'.'은 패턴작성에 사용되는 문자이므로 escape문자인 '＼'를 사용해야 한다.|c.,|
|c\d<br>c[0-9]|c와 숫자로 구성된 두자리 문자열|c0,|
|c.*t|c로 시작하고 t로 끝나는 모든 문자열|combat,count,|
|[b｜c].* <br> [bc].* <br> [b-c].*|b 또는 c로 시작하는 문자열|bat,baby,bonus,c,cA,ca,co,c.,c0,c#,car,combat,count,|
|[^b｜c].* <br> [^bc].* <br> [^b-c].*|b 또는 c로 시작하지 않는 문자열|date,disc,|
|.＊a.＊|a를 포함하는 모든 문자열<br>* : 0 또는 그 이상의 문자|bat,baby,ca,car,combat,date,|
|.*a.+|a를 포함하는 모든 문자열.<br>+ : 1 또는 그 이상의 문자. '+'는 '＊'과는 달리 반드시 하나 이상의 문자가 있어야 하므로 a로 끝나는 단어는 포함되지 않았다.|bat,baby,car,combat,date|
|[b｜c].{2}|b 또는 c로 시작하는 세 자리 문자열.(b 또는 c다음에 두 자리이므로 모두 세자리)|bat,car,|

<br>

**그룹화 예제**
```java
class RegularEx {
    public static void main(String[] args) {
        String source = "HP:011-1111-1111, HOME:02-999-9999 ";
        String pattern = "(0\\d{1,2})-(\\d{3,4})-(\\d{4})";

        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(source);

        int i = 0;
        while (m.find()) {
            System.out.println(++i + ": " + m.group() + " -> "
                    + m.group(1) + ", " + m.group(2) + ", " + m.group(3));
        }
    }
}
```
실행결과

    1: 011-1111-1111 -> 011, 1111, 1111
    2: 02-999-9999 -> 02, 999, 9999

|<center>정규식 패턴</center>|<center>설명</center>|
|:-|:-|
|0\\\\d{1,2}|0으로 시작하는 최소 2자리 최대 3자리 숫자(0포함)|
|\\\\d{3,4}|최소 3자리 최대 4자리 숫자|
|\\\\d{4}|4자리 숫자|