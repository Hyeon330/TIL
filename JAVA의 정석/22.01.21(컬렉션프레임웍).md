Iterator, ListIterator, Enumeration
---
- Iterator, ListIterator, Enumeration은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스이다.
- Enumeration은 Iterator의 구버전
- ListIterator는 Iterator의 신버전

### **Iterator**
컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의하고, Collection인터페이스에는 'Iterator(Iterator를 구현한 클래스의 인스턴스)'를 반환하는 iterator()를 정의하고 있다.

```java
public interface Iterator {
    boolean hasNext();
    Object next();
    void remove();
}

public interface Collection {
    ...
    public Iterator iterator();
    ...
}
```

interator()는 Collection인터페이스에 정의된 메서드이므로 Collection인터페이스의 자손인 List와 Set에도 포함되어 있다. 컬렉션 클래스에 대해 iterator()를 호출하여 Iterator를 얻은 다음 반복문, 주로 while문을 사용해서 컬렉션 클래스의 요소들을 읽어 올 수 있다.

|<center>메서드</center>|<center>설명</center>|
|:-|:-|
|boolean hasNext()|읽어 올 요소가 남아있는지 확인한다. 있으면 true, 없으면 false를 반환한다.|
|Object next()|다음 요소를 읽어 온다. next()를 호출하기 전에 hasNext()를 호출해서 읽어올 요소가 있는지 확인하는 것이 안전하다.|
|void remove()|next()로 읽어 온 요소를 삭제한다. next()를 호출한 다음에 remove()를 호출해야 한다.(선택정 기능)|

**Collection인터페이스를 구현한 컬렉션 클래스를 Iterator로 변환 및 출력**
```java
Collection c = new ArrayList();  // 다른 컬렉션으로 변경시 이 부분만 고치면 된다.
Iterator it = c.iterator();

while(it.hasNext()) {
    System.out.println(it.next());
}
```

Map인터페이스의 경우 키(Key)와 값(Value)을 쌍(pair)으로 저장하고 있기 때문에 iterator()를 직접 호출할 수 없고, 그 대신 keySet()이나 entrySet()과 같은 메서드를 통해 키와 값을 각각 따로 Set의 형태로 얻어 온 후에 다시 iterator()를 호출해야 Iterator를 얻을 수 있다.
```java
Map map = new HashMap();
Iterator it = map.enterySet().iterator();
```

**iterator활용 예제**
```java
import java.util.*;

class IteratorEx {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");

        Iterator = it = list.iterator();

        while(it.hasNext()){
            Object obj = it.next();
            System.out.println(obj);
        }
    }
}
```
실행결과

    1
    2
    3
    4
    5

>List클래스들은 저장순서를 유지하기 때문에 읽어온 결과가 저장 순서와 동일하지만, Set클래스들은 요소간의 순서가 유지되지 않기 때문에 Iterator를 이용해서 저장된 요소들을 읽어 와도 처음에 저장된 순서와 같지 않다.

<br>

### **ListIterator와 Enumeration**
- Enumeration은 컬렉션 프레임웍이 만들어지기 이전에 사용하던 것.
- ListIterator는 Iterator를 상속받아서 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있지만, ListIterator는 양방향으로 이동이 가능하다. 단, List인터페이스를 구현한 컬렉션에서만 가능하다.

- **Iterator인터페이스의 메서드**
<p align="center">
<img src="../TIL_img/22.01.21(CollectionFramework)/EnumerationInterfaceMethod.jpg" width="90%">
</p>

- **ListIterator의 메서드**
<p align="center">
<img src="../TIL_img/22.01.21(CollectionFramework)/ListIteratorMethod.jpg" width="90%">
</p>

```java
import java.util;

class ListIteratorEx {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");

        ListIterator it = list.listIterator();

        while(it.hasNext()) {
            System.out.print(it.next()); // 순방향으로 진행하면서 읽어온다.
        }
        System.out.println();
        while(it.hasPrevious()) {
            System.out.print(it.previous()); // 역방향으로 진행하면서 읽어온다.
        }
        System.out.println();
    }
}
```
실행결과

    12345
    54321

단방향으로만 이동하는 Iterator과는 달리 ListIterator는 양방향으로 이동하기 때문에 각 요소간의 이동이 자유롭다. 다만 이동하기 전에 반드시 hasNext()나 hasPrevious()를 호출해서 이동할 수 있는지 확인해야 한다.

ListIterator의 메서드 중 '선택정 기능(optional Operation)'이라고 표시된 것들은 반드시 구현하지 않아도 된다. 그렇다하더라도 인터페이스로부터 상속받는 메서드는 추상메서드라 메서드의 몸통(body)을 반듯이 만들어 주어야 하므로 단순히 ```public void remove(){};```와 같이 구현하는 것 보다
```java
public void remove() {
    throw new UnsupportedOperationExption();
}
```
이처럼 예외를 던져서 구현하지 않는 기능이라는 것을 메서드를 호출하는 쪽에 알리는 것이 좋다.

**remove()메서드 활용 예제**
```java
package day_22_01_21;

import java.util.*;

public class IteratorEx {
    public static void main(String[] args) {
        ArrayList original = new ArrayList();
        ArrayList copy1 = new ArrayList();
        ArrayList copy2 = new ArrayList();

        for (int i = 0; i < 10; i++) {
            original.add(i + "");
        }
        Iterator it = original.iterator();

        while (it.hasNext())
            copy1.add(it.next());

        System.out.println("= Original에서 copy1로 복사(copy) =");
        System.out.println("original:" + original);
        System.out.println("copy1:" + copy1);
        System.out.println();

        it = original.iterator(); // Iterator는 재사용이 안되므로, 다시 얻어와야 함.

        while (it.hasNext()) {
            copy2.add(it.next());
            it.remove();        // 값을 copy2에 넣고 바로 제거
        }

        System.out.println("= Original에서 copy2로 이동(move) =");
        System.out.println("original:" + original);
        System.out.println("copy2:" + copy2);
    }
}
```
**Iterator를 상속한 Itr클래스의 remove메서드 소스코드**
```java
private class Itr implements Iterator<E> {
    int cursor;       // 앞으로 읽어올 요소의 위치
    int lastRet = -1; // 마지막으로 읽어온 요소의 위치(index)
    int expectedModCount = modCount;

    public void remove() {
        if (lastRet < 0)    // lastRet이 0보다 작을경우(-1일 경우, next를 호출하지 않고 remove()가 호출된 경우)
            throw new IllegalStateException();  // 예외 발생!!!
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}
```
cursor는 앞으로 읽어올 요소의 위치를 저장하는데 사용되고, lastRet는 마지막으로 읽어온 요소의 위치(index)의 위치를 저장하는데 사용된다.

lastRet는 cursor보다 항상 1이 작은 값이 저장되고 remove()를 호출하면 이미 next()를 통해서 lastRet에 저장된 값의 위치에 있는 요소를 삭제하고 lastRet의 값을 -1로 초기화 한다.

만약 next()를 호출하지 않고 remove()를 호출하면 lastRet의 값은 -1이 되어 'IllegalStateException'이 발생한다. remove()는 next()로 읽어온 객체를 삭제하는 것이기 때문에 remove()를 호출하기 전에 반드시 next()가 호출된 상태이어야 한다.


###### <br>

Arrays
---
- Arrays클래스에는 배열을 다루는데 유용한 메서드가 정의되어 있다.

### **배열의 복사-copyOf(), copyOfRange()**

    copyOf() - 배열의 전체를 복사해 새로운 배열을 만들어 반환
    
    copyOfRange() - 배열의 일부를 복사해 새로운 배열을 만들어 반환
                  - 지정된 범위의 끝은 포함되지 않는다.

```java
int[] arr = {0,1,2,3,4};
int[] arr2 = Arrays.copyOf(arr, arr.length);    // arr2 = {0,1,2,3,4}
int[] arr3 = Arrays.copyOf(arr, 3);             // arr2 = {0,1,2}
int[] arr4 = Arrays.copyOf(arr, 7);             // arr2 = {0,1,2,3,4,0,0}
int[] arr5 = Arrays.copyOfRange(arr, 2, 4);     // arr2 = {2,3} ← 4는 불필요
int[] arr6 = Arrays.copyOfRange(arr, 0, 7);     // arr2 = {0,1,2,3,4,0,0}